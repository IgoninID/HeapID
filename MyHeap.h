// Автор: Игонин В.Ю.

#pragma once
#include "../TemplArr/Arr.h"

template <typename T>
void HeapMake(DynArr<T>& arr, size_t size, size_t i)
{
	size_t large = i;
	size_t left = 2 * i + 1;
	size_t right = 2 * i + 2;
	if (left < size && arr[left] > arr[large])
	{
		large = left;
	}
	if (right < size && arr[right] > arr[large])
	{
		large = right;
	}
	if (large != i)
	{
		swap(arr[i], arr[large]);
		//T temp = arr[i];
		//arr[i] = arr[large];
		//arr[large] = temp;
		HeapMake(arr, size, large);
	}
}

template <typename T>
void HeapSort(DynArr<T>& arr, size_t size)
{
	for (int i = size / 2 - 1; i >= 0; i--)
	{
		HeapMake(arr, size, i);
	}
	for (int i = size - 1; i >= 0; i--)
	{
		swap(arr[0], arr[i]);
		HeapMake(arr, i, 0);
	}
}

// Шаблонный класс MyHeap, реализующий структуру данных "максимальная куча" (max-heap)
template <typename T>
class MyHeap
{
private:
    DynArr<T> arr; // Динамический массив для хранения элементов кучи
    size_t size;   // Текущий размер кучи (количество элементов)

    /// <summary>
    /// Поднимает элемент с указанным индексом вверх по куче, чтобы восстановить свойство кучи.
    /// </summary>
    /// <param name="ind">Индекс элемента, который нужно поднять.</param>
    void up(size_t ind)
    {
        while (ind > 0)
        {
            size_t par = (ind - 1) / 2;
            if (arr[ind] > arr[par])
            {
                swap(arr[ind], arr[par]);
                ind = par;
            }
            else
            {
                break;
            }
        }
    }

    /// <summary>
    /// Опускает элемент с указанным индексом вниз по куче, чтобы восстановить свойство кучи.
    /// </summary>
    /// <param name="ind">Индекс элемента, который нужно опустить.</param>
    void down(size_t ind)
    {
        while (true)
        {
            size_t left = 2 * ind + 1;
            size_t right = 2 * ind + 2;
            size_t large = ind;
            if (left < size && arr[left] > arr[large])
            {
                large = left;
            }
            if (right < size && arr[right] > arr[large])
            {
                large = right;
            }
            if (large != ind)
            {
                swap(arr[ind], arr[large]);
                ind = large;
            }
            else
            {
                break;
            }
        }
    }

public:
    /// <summary>
    /// Конструктор по умолчанию. Создает пустую кучу.
    /// </summary>
    MyHeap()
    {
        size = 0;
    }

    /// <summary>
    /// Конструктор, создающий кучу из динамического массива.
    /// </summary>
    /// <param name="arr">Динамический массив, на основе которого создается куча.</param>
    MyHeap(const DynArr<T>& arr) : arr(arr)
    {
        this->size = arr.length();
        for (long long i = this->size / 2 - 1; i >= 0; i--)
        {
            down(i);
        }
    }

    /// <summary>
    /// Конструктор копирования. Создает кучу на основе другой кучи.
    /// </summary>
    /// <param name="heap">Куча, из которой копируются данные.</param>
    MyHeap(const MyHeap<T>& heap) : arr(heap.arr)
    {
        this->size = heap.size;
    }

    /// <summary>
    /// Конструктор перемещения. Переносит данные из другой кучи.
    /// </summary>
    /// <param name="heap">Куча, из которой переносятся данные.</param>
    MyHeap(MyHeap<T>&& heap) noexcept : arr(heap.arr)
    {
        this->size = heap.size;
        heap.size = 0;
        heap.arr.Clear();
    }

    /// <summary>
    /// Оператор присваивания (копирование).
    /// </summary>
    /// <param name="heap">Куча, из которой копируются данные.</param>
    /// <returns>Ссылка на текущую кучу после присваивания.</returns>
    MyHeap<T>& operator = (const MyHeap<T>& heap)
    {
        return MyHeap(heap);
    }

    /// <summary>
    /// Оператор присваивания (перемещение).
    /// </summary>
    /// <param name="heap">Куча, из которой переносятся данные.</param>
    /// <returns>Ссылка на текущую кучу после присваивания.</returns>
    MyHeap<T>& operator = (MyHeap<T>&& heap)
    {
        if (this != &heap)
        {
            return MyHeap(heap);
        }
        return *this;
    }

    /// <summary>
    /// Возвращает ссылку на внутренний массив кучи.
    /// </summary>
    /// <returns>Ссылка на динамический массив, содержащий элементы кучи.</returns>
    DynArr<T>& getArr()
    {
        return arr;
    }

    /// <summary>
    /// Возвращает текущий размер кучи.
    /// </summary>
    /// <returns>Количество элементов в куче.</returns>
    size_t getSize() const
    {
        return size;
    }

    /// <summary>
    /// Возвращает максимальный элемент кучи (корень).
    /// </summary>
    /// <returns>Ссылка на максимальный элемент кучи.</returns>
    /// <exception cref="runtime_error Выбрасывается, если куча пуста."></exception>
    T& Max()
    {
        if (empty()) throw runtime_error("Куча пустая");
        return arr[0];
    }

    /// <summary>
    /// Вставляет новый элемент в кучу.
    /// </summary>
    /// <param name="data">Элемент, который нужно вставить.</param>
    void Insert(T data)
    {
        arr.pushBack(data);
        size += 1;
        up(size - 1);
    }

    /// <summary>
    /// Проверяет, пуста ли куча.
    /// </summary>
    /// <returns>Возвращает true, если куча пуста, иначе false.</returns>
    bool empty() const
    {
        return size == 0;
    }

    /// <summary>
    /// Удаляет максимальный элемент из кучи.
    /// </summary>
    /// <exception cref="runtime_error Выбрасывается, если куча пуста."></exception>
    void Remove()
    {
        if (empty()) throw runtime_error("Куча пустая");
        if (size == 1)
        {
            arr.popFront();
            return;
        }
        arr[0] = arr[size - 1];
        arr.popBack();
        down(0);
        size -= 1;
    }

    /// <summary>
    /// Ищет элемент в куче и возвращает его индекс.
    /// </summary>
    /// <param name="data">Элемент, который нужно найти.</param>
    /// <returns>Индекс найденного элемента.</returns>
    /// <exception cref="runtime_error Выбрасывается, если куча пуста."></exception>
    /// <exception cref="overflow_error Выбрасывается, если элемент не найден."></exception>
    size_t Find(T data)
    {
        if (empty()) throw runtime_error("Куча пустая");
        for (size_t i = 0; i < size; i++)
        {
            if (arr[i] == data)
            {
                return i;
            }
        }
        throw overflow_error("Нет такого элемента");
    }

    /// <summary>
    /// Деструктор. Освобождает память, занятую кучей.
    /// </summary>
    ~MyHeap()
    {
        arr.Clear();
    }
};


void test();